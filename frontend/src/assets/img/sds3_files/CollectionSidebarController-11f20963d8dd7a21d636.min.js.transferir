(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{14417:function(e,t,i){"use strict";i.r(t),function(e){i.d(t,"default",(function(){return E}));var s,r,n=i(1251),o=i(14401),a=i(4233),c=i(4231),d=i(4236),l=i(4239),u=i(14418),b=i(2082),h=i(4612),p=i(2870),m=i(3244),S=i(3314),f=i(3218);function g(e,t,i,s,r){var n={};return Object.keys(s).forEach((function(e){n[e]=s[e]})),n.enumerable=!!n.enumerable,n.configurable=!!n.configurable,("value"in n||n.initializer)&&(n.writable=!0),n=i.slice().reverse().reduce((function(i,s){return s(e,t,i)||i}),n),r&&void 0!==n.initializer&&(n.value=n.initializer?n.initializer.call(r):void 0,n.initializer=void 0),void 0===n.initializer&&(Object.defineProperty(e,t,n),n=null),n}let E=(r=g((s=class{constructor(){var e,t,i,s;this.model=null,this._adapters=[],e=this,t="status",s=this,(i=r)&&Object.defineProperty(e,t,{enumerable:i.enumerable,configurable:i.configurable,writable:i.writable,value:i.initializer?i.initializer.call(s):void 0})}async didCreate(){if(this.model=new o.default,"browser"!==window.SDK_PLATFORM){if(!pm.isScratchpad){const t=await this._fetchCollections();this.setSidebarStatus(h.READY),function(t){if(e.isEmpty(t))return;const i=[],s=[],r=[],n=[];t.forEach(t=>{const o=e.get(t,"attributes.flags.isFavorite"),a=e.get(t,"attributes.permissions.teamCanView"),c=e.get(t,"attributes.permissions.anybodyCanView"),d=e.get(t,"attributes.flags.isArchived"),l=Object(m.decomposeUID)(t.id).modelId,u={id:l};o&&i.push(u),a&&s.push(u),c&&r.push({id:t.id}),d&&n.push({model:"collection",modelId:l})}),!e.isEmpty(i)&&Object(p.getStore)("FavoritedCollectionStore").add(i),!e.isEmpty(s)&&Object(p.getStore)("SharedCollectionsStore").add(s),!e.isEmpty(r)&&Object(p.getStore)("PublicEntityStore").add(r),!e.isEmpty(n)&&Object(p.getStore)("ArchivedResourceStore").add(n)}(t)}const t=await b.default.getActiveSession(),i=t&&t.workspace;if(!i)return this.setSidebarStatus(h.ERROR),Promise.reject(new Error("CollectionSidebarController~didCreate: Could not find the active workspace"));const s=new a.default(this.model.getCollectionAdapterModel(),{activeWorkspace:i,useUID:!0}),r=new c.default(this.model.getFolderAdapterModel()),n=new d.default(this.model.getRequestAdapterModel()),o=[s.hydrate(),r.hydrate(),n.hydrate()];return this._adapters.push(s,r,n),Promise.all(o).then(()=>{const e=new l.default(this.model.getResponseAdapterModel());return this._adapters.push(e),this.setSidebarStatus(h.READY),e.hydrate()})}const t=new u.default(this.model.getCollectionAdapterModel());this._adapters.push(t),t.hydrate().then(()=>{this.setSidebarStatus(h.READY)}).catch(e=>{this.setSidebarStatus(h.ERROR),pm.logger.error("CollectionSidebarController~fetchCollections: Error in loading collection list",e)})}beforeDestroy(){this._adapters&&this._adapters.forEach(t=>{e.isFunction(t.dispose)&&t.dispose()}),this.model=null,this._adapters=[]}setSidebarStatus(e){this.status=e}_fetchCollections(){return Object(p.getStore)("SyncStatusStore").onSyncAvailable().then(()=>{const e=Object(p.getStore)("ActiveWorkspaceStore").id;return m.RemoteSyncRequestService.request(S.COLLECTION_LIST_AND_SUBSCRIBE`${e}`,{method:"POST",timeout:3e4})}).then(t=>{const i=e.forEach(e.get(t,"body.data",[]),t=>{const i={model:"collection",modelId:t.id,action:"UPDATE_COLLECTION"},s=f.default.getCompositeKey(i);!Object(p.getStore)("PermissionStore").members.has(s)&&e.set(t,"attributes.permissions.userCanUpdate",!0)});return this.model.hydrate&&this.model.hydrate(i),i})}}).prototype,"status",[n.observable],{enumerable:!0,initializer:function(){return h.LOADING}}),g(s.prototype,"setSidebarStatus",[n.action],Object.getOwnPropertyDescriptor(s.prototype,"setSidebarStatus"),s.prototype),s)}.call(this,i(1026))},14418:function(e,t,i){"use strict";i.r(t),function(e){i.d(t,"default",(function(){return c}));var s=i(14419),r=i(2870),n=i(3314),o=i(2095),a=i(2100);let c=class extends s.default{getListAndSubscribeAPIEndpoint(){const e=Object(r.getStore)("ActiveWorkspaceStore").id;return n.COLLECTION_LIST_AND_SUBSCRIBE`${e}`}getListAPIEndpoint(){const e=Object(r.getStore)("ActiveWorkspaceStore").id;return n.COLLECTION_LIST`${e}`}dispose(){super.dispose(),this.unsubscribeModelEvents&&this.unsubscribeModelEvents()}_subscribeToChangeEvents(t){super._subscribeToChangeEvents(t),this.unsubscribeModelEvents&&this.unsubscribeModelEvents(),this.unsubscribeModelEvents=null,this.unsubscribeModelEvents=pm.eventBus.channel("model-events").subscribe(t=>{if("collection"!==Object(o.getEventNamespace)(t))return;const i=Object(o.getEventName)(t);if(!["favorite","unfavorite"].includes(i))return;const s=Object(o.getEventData)(t),r=e.get(s,"collection.id"),n=e.get(s,"collection.owner"),c=Object(a.composeUID)(r,n),d="favorite"===i;this.model.updateFavorite&&this.model.updateFavorite(c,d)})}}}.call(this,i(1026))},14419:function(e,t,i){"use strict";i.r(t),function(e){i.d(t,"default",(function(){return c}));var s=i(4220),r=i(2927),n=i(2517),o=i(14420),a=i(2870);let c=class extends s.default{getListAndSubscribeAPIEndpoint(){throw new Error(this.constructor.name+"~getListAndSubscribeAPIEndpoint: not implemented")}getListAPIEndpoint(){throw new Error(this.constructor.name+"~getListAPIEndpoint: not implemented")}hydrate(t=!0){return new Promise((i,s)=>{this._connection_subscription=Object(r.getSocketConnectionObservable)().subscribe(r=>{if("connect"===r)return this._getAPIResponse().then(i=>{const s=e.get(i,"body.data",[]),r=e.get(i,"body.subscription.id");this._hydrateEntities(s),t&&r&&this._subscribeToChangeEvents(r)}).then(()=>i()).catch(e=>(pm.logger.warn("ListingAPIAdapter~hydrate: Failed to hydrate entities",e),s(e)))})})}dispose(){super.dispose(),this._connection_subscription&&this._connection_subscription.unsubscribe(),this._realtime_subscription&&this._realtime_subscription.unsubscribe()}_hydrateEntities(e){this.model.hydrate&&this.model.hydrate(e)}_removeEntities(t){e.isEmpty(t)||this.model.remove&&this.model.remove(t)}_addEntities(t){e.isEmpty(t)||this.model.add&&this.model.add(t)}async _getAPIResponse(){return await Object(a.getStore)("SyncStatusStore").onSyncAvailable(),n.default.request(this.getListAndSubscribeAPIEndpoint(),{method:"POST",timeout:3e4})}_subscribeToChangeEvents(t){this._realtime_subscription&&this._realtime_subscription.unsubscribe(),this._realtime_subscription=Object(o.realtimeEventsForSubscription)(t).subscribe(t=>{const i=e.get(t,"data.data",[]),s=i.filter(({action:e})=>["create","update"].includes(e)).map(({id:e})=>e),r=i.filter(({action:e})=>"delete"===e).map(({id:e})=>e);this._removeEntities(r),this._createOrUpdateEntities(s)})}async _createOrUpdateEntities(t){if(e.isEmpty(t))return;await Object(a.getStore)("SyncStatusStore").onSyncAvailable();const i=await n.default.request(this.getListAPIEndpoint(),{method:"POST",data:{ids:t},timeout:3e4}),s=e.get(i,"body.data",[]);this._addEntities(s)}}}.call(this,i(1026))},14420:function(e,t,i){"use strict";i.r(t),function(e){i.d(t,"realtimeEventsForSubscription",(function(){return n}));var s=i(3015),r=i(3117);function n(t){return Object(r.getRealtimeMessagesObservable)().pipe(Object(s.filter)(i=>e.get(i,"data.subscription.id")===t))}}.call(this,i(1026))}}]);
//# sourceMappingURL=CollectionSidebarController-11f20963d8dd7a21d636.min.js.map